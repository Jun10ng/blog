---
title: Go语言编程中的面向对象编程原则
comment:
  - false
categories:
  - [Go设计模式与并发模式]
  - [Golang]
tags:
  - design patern
photos:
  - https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1360484254,192420539&fm=26&gp=0.jpg
date: 2020-06-29 15:29:34
---

本文介绍了编程中，应当注意的几个面向对象的设计原则。合理使用这些原则设计代码架构与接口能够使得我们的代码可复用、可维护、可扩展。

# 前言

本文说到的接口分为广义接口和狭义接口。
广义接口包括接口和抽象类，而狭义接口则单指编程语言中的接口（interface）。

## 变化与不变化

找出应用中可能需要变化之处，把他们独立出来，不要和那些**不需要变化**的代码混合在一起。

有两种独立方法：

* 第一类通过配置文件独立，比如`config`文件，这类方法多用于变化的对象是**架构组件**，比如把数据源从`mysql`改为`Redis`。我们可以通过配置文件来实现，软件运行前的变化。
* 第二类是把会变化的部分取出并封装为对象，以便以后可以轻易地改动或扩充此部分，这样就不会影响到不需要改动的部分了。这类方法多用于软件运行时的场景，把封装的对象作为参数注入处理函数中。不同的用户都需要实现身份验证，但验证的过程是一样。这就是一个变化与不变化的例子。


### 面向接口编程而不是面向实现编程

当接到一个需求时，如果使用面向对象为粒度去解析需求，经常会无从入手，但是如果再抽象点，以接口为粒度，甚至以模式为粒度去解析需求，那么就游刃有余了。

如果这个接口有人写过，我们只要实现它就好了，如果这个接口还没人写过，那么恭喜你，你可以定义它了。
而以模式为粒度去解析需求稍微负责点，因为很少有需求只单一地用到一个模式，多是复合模式，在《设计模式》一书中，每个模式都有多个_参与者_，而这里的参与者其实就是我们说的接口。所以这三种面向**编程其实是一脉相承，是方法论的进化。这种方法以后再讲，先留个坑。

这里讲的接口，指的是广义的接口，而不是编程语言里的`interface`关键字。


面向接口编程是指设计类时，把实现的细节放在接口中，把一些实质动作，会改变的动作抽象成接口，然后在接口中实现，因为这些实现细节是很容易改变的有，因此我们要把他组件化，使其可复用。比如实现“小明吃苹果”可以针对接口实现“{人接口}{动作接口}{对象接口}”，然后在三个接口中分别实现小明类，吃动作类，苹果类。以后若还有类似需求，比如小明在切苹果。只要实现切动作类即可。具体的例子看下面。

### Go语言中的面向接口编程

本章节通过两个来说说`Go`语言中的面向接口编程，一个是`Go`内部的`Writer`接口，一个是我们自己想的需求。

#### Writer接口

你肯定知道`Go`中的`Writer`，`Reader`，`Closer`等一系列类似的接口。以`Writer`为例，只要有`Write`方法，就相当于实现了`Writer`接口，。而我们也可以指定某个成员或者参数要实现`Writer`接口，有自己的`write`方法，这个其实就是面向接口编程。高层不需要了解底层的实现原理，下次我要换个组件也很方便，你满足了我的要求就可以了（可替换性）。

我们来看下`os.File`和`bytes.buffer`这两个类的`Write`方法，他们一个向文件写入数据，一个向缓冲区写数据，但是他们都实现了`Writer`接口，所以在调用他们的时候，不需要考虑底层实现是什么，反正都是“写”，写就完事了~

以下是`os.File`的`Write`方法。
```go
// Write 把长度为 len(b) 的byte数据写入文件中
// 返回写入长度和一个错误
func (f *File) Write(b []byte) (n int, err error) {
	if err := f.checkValid("write"); err != nil {
		return 0, err
	}
	n, e := f.write(b)
	if n < 0 {
		n = 0
	}
	if n != len(b) {
		err = io.ErrShortWrite
	}

	epipecheck(f, e)

	if e != nil {
		err = f.wrapErr("write", e)
	}

	return n, err
}
```
以下是`bytes.Buffer`的`Write`方法：

```go
// Write 把 p 中的数据写入b的缓冲区中
// 并在需要的时候扩大缓冲区。
func (b *Buffer) Write(p []byte) (n int, err error) {
	b.lastRead = opInvalid
	m, ok := b.tryGrowByReslice(len(p))
	if !ok {
		m = b.grow(len(p))
	}
	return copy(b.buf[m:], p), nil
}
```

#### 小小设想一下

我们接到一个需求，要实现一个**毛笔类**，那还不是小意思。

```go
// 毛笔
type Brush struct {
}

func (b *Brush) FillInk() {
	fmt.Println("开始磨墨，蘸墨")
}
func (b *Brush) Write() {
	fmt.Println("写个天道酬勤")
}
```
你可能对此不屑一顾，觉得上面的代码太“烂”，完全写死了，自定义参数都没有。那我们改一下吧。


```go
// 毛笔2.0
type Brush struct {
	// 墨水类型
	InkType string

}

func (b *Brush) FillInk() {
	fmt.Printf("开始磨墨，蘸点%v", b.InkType)
}
func (b *Brush) Write(p []byte) {
	fmt.Printf("写个%v", p)
}
```
这样看起来似乎还不错，但是如果接下来又要实现圆珠笔呢？圆珠笔要蘸墨吗？好像不用诶，如果又要实现钢笔呢？钢笔不用蘸墨但是要定期装墨诶，如果实现玩具笔呢？不用书写，连墨也不用了！

有个科学家说过：“在软件开发中，唯一不变的就是变化”。你永远不知道。**们会有啥奇思妙想。

所以在一开始设计，我们就应该留下可扩展的地方，下面我们这样设计，把笔的每个动作设计成接口。以接口为单位去实现一只笔。
给每个笔添加两个成员对象，分别是墨水动作接口对象和写接口对象，我们把笔的动作委托给了这两个对象去实现，而笔本身的装墨方法和写方法，则是调用这两个对象内的方法实现。

这样子，我们就能是选择不同的接口对象组装一直笔了。

```go
// 墨水动作接口
type FillInker interface {
	FillInk()
}

// 写接口，就是io.Writer，不重复实现了

// 毛笔的蘸墨
type BrushInk struct {
	InkType string
}

func (bi *BrushInk) FillInk() {
	fmt.Printf("开始磨墨，蘸点%v", bi.InkType)
}

// 毛笔的写
type BrushWrite struct {
}

func (bw *BrushWrite) Write(p []byte) {
	fmt.Printf("写个%v", p)
}

type Brush struct {
	InkFill FillInker
	PenWite io.Writer
}

func NewBrush(fillInker FillInker, writer io.Writer) Brush {
	return Brush{
		InkFill: fillInker,
		PenWite: writer,
	}
}
func (b *Brush) FillInk() {
	b.InkFill.FillInk()
}
func (b *Brush) Write(p []byte) {
	b.PenWite.Write(p)
}
```

因为这里只实现了一个毛笔类，所以看起来比前两个写法冗长很多，但是在实际中，这样的写法最具有复用性的，比如我们以这个写法实现**圆珠笔，钢笔，鹅毛笔，玩具笔，不出墨的钢笔**。其中圆珠笔和钢笔可以共用一个写接口对象，鹅毛笔和毛笔可以共用一个墨水动作接口对象，玩具笔和不出墨的钢笔可以共用写对象，等等。

这里还可以再抽象点，定义一个笔接口，然后使用工厂模式生成这么多种类的笔。这是后话，我会在介绍工厂模式的博文中实现。


这样一来，在**增加新鸭子类**的时候，可以通过硬编码方式静态添加，也可以通过构造函数，传入接口动作参数动态生成新的鸭子类。
**这样就把实现的细节委托给了接口对象。**

### 里氏替换原则（LSP）

父类出现的地方可以用子类代替，而不用修改什么。

想深一点LSP其实是对“面向接口编程”的修正，因为他们都要求松耦合和OOP。

### 小小设想一下

现在要实现“人写字”的动作，那么我肯定要握着一根笔，不管是毛笔还是钢笔，只要能写就好。
那么这里的参数就应该是“笔”接口，它能允许被替换成毛笔和钢笔对象。

这里的笔是父类，毛笔和钢笔是子类，当我们把笔类换成钢笔毛笔，程序不出错，那么就称为符合`LSP`。



### 为了交互对象之间的松耦合设计而努力

这能简历有弹性的OO系统，能够应付变化，因为对象之间的**相互依赖**降到了最低。

### 开放-关闭模式

对修改关闭，对扩展开放。

一个优秀的架构应该具有良好的扩展性，而对修改关闭，以避免修改后引入新bug和损坏依赖。
使用装饰器可以满足这个设计原则。**扩展时先考虑组合，在考虑继承。**

但其实，对已变化的部分小部分修改代码是可以接受的，比如`if-else`分支。

### 依赖倒置原则

要依赖抽象而不是依赖具体类。
这个原则很像“面向接口编程”原则，在编程中，我们不能让高层组件直接依赖底层组件，不管高层底层，都应该依赖抽象。这个原则工厂模式总得到了体现。
依赖倒置中的倒置意思见下图：
![依赖倒置](https://s1.ax1x.com/2020/05/27/tEp0I0.png)

将高层组件所依赖的组件抽象成抽象类或接口，而底层组件的调用也返回一个抽象类，或者实现这个抽象类。这样就能实现依赖倒置，并且解耦。
看下工厂模式的部分类图
![工厂](https://s1.ax1x.com/2020/05/27/tE9mWT.png)
工厂方法和具体产品都依赖产品这个抽象类或接口，也就是解耦合，我们可以不修改代码，就能添加新的子产品类，只要这个类实现了产品类接口。

### 单一职责

一个类应该只有一个引起变化的原因。



## 后记

第一次写这样的长文，没想到这么考验自己，是一种榨干自己的过程。 后面的几个原则我一时没想好有什么简单的例子可以展示，先放着。

以上内容，欢迎指正，共同进步 ~